bplist00Ñ_WebMainResourceÕ	
_WebResourceData_WebResourceMIMEType_WebResourceTextEncodingName_WebResourceFrameName^WebResourceURLO3(<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/2000/REC-xhtml1-20000126/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="cs"><head>
    <meta name="generator" content="PSPad editor, www.pspad.com">
    <meta http-equiv="content-type" content="text/html; charset=utf-8"><title>A4B33OSS: ZadÃ¡nÃ­ semstrÃ¡lnÃ­ch pracÃ­: SÃ­tÄ›</title>
	 <style type="text/css">
		 code {background-color:#ddd; display:block; padding:10px;}
		 table.packet {background-color:black; margin: 5px;}
		 table.packet td {background-color: #DDD; color:black; padding:3px 10px 3px 10px;}
	 </style>
    <style>
      @import 'style.css';
	</style>
	</head>
	<body>
    <h1>SemestrÃ¡lnÃ­ prÃ¡ce z pÅ™edmÄ›tu A4B33OSS</h1>

<p>
CÃ­lem tÃ©to prÃ¡ce je zkusit si nÄ›kterÃ© zpÅ¯soby implementace algoritmÅ¯ z oblasti sÃ­tÃ­. PÅ™i vytvÃ¡Å™enÃ­ programÅ¯, kterÃ© komunikujÃ­ pomocÃ­ externÃ­ho spojenÃ­ je vÅ¾dy velkÃ½ dÅ¯raz kladen na schopnost
detekce chyby a Å™eÅ¡enÃ­ nastalÃ© situace. 
</p>

    <p>PrvnÃ­ dvÄ› Ãºlohy jsou zamÄ›Å™enÃ© na implementaci algoritmÅ¯ protokolovÃ©ho zÃ¡sobnÃ­ku. PouÅ¾itÃ­ protokolovÃ©ho zÃ¡sobnÃ­ku mÃ¡ velmi uÅ¾iteÄnou vlastnost: kaÅ¾dÃ¡ vrstva mÃ¡ na starosti jednoduchou
    dobÅ™e definovanou Ãºlohu a mÅ¯Å¾e se spolehnout na korektnÃ­ Å™eÅ¡enÃ­ problÃ©mÅ¯ ostatnÃ­mi vrstvami.<br>
    DruhÃ© dvÄ› Ãºlohy se zamÄ›Å™ujÃ­ na smÄ›rovÃ¡nÃ­ zprÃ¡v s sÃ­tÃ­ch. PrvnÃ­ je spÃ­Å¡e zamÄ›Å™ena na synchronizaci procesÅ¯ pÅ™Ã­padnÄ› vlÃ¡ken, druhÃ¡ je zamÄ›Å™ena na smÄ›rovÃ¡nÃ­ v sÃ­ti, jejÃ­Å¾ topologie se mÅ¯Å¾e mÄ›nit.
    </p>
    <p>
    Pro implementaci vytvoÅ™te skupiny 2 studnetÅ¯. VÃ¡Å¡ program by mÄ›l bÃ½t pÅ™ehlednÃ½, dobÅ™e komentovanÃ½ a samozÅ™ejmÄ› funkÄnÃ­. Pokud je to u Ãºlohy vyÅ¾adovÃ¡no, musÃ­ umÄ›t VÃ¡Å¡ program simulovat
    nÄ›kterÃ© chyby sÃ­Å¥ovÃ©ho spojenÃ­.
 </p>
    <p>AÅ¾ si vyberete, poÅ¡lete svÃ©mu cviÄÃ­cÃ­mu mail, kde bude uvedeno, na jakÃ½
pÅ™edmÄ›t a kdy chodÃ­te, vÃ¡mi utvoÅ™enÃ¡ skupina (tj. dvÄ› jmÃ©na) a <strong>seznam</strong>
dvou Ãºloh, kterÃ© byste rÃ¡di Å™eÅ¡ili. Pokud mÃ¡ nÄ›kterÃ¡ Ãºloha variantu poÅ¡lete i jakÃ½ pÃ­smeno specifikujÃ­cÃ­ variantu Ãºlohy.</p>
<p>
  Studenti, kteÅ™Ã­ mail cviÄÃ­cÃ­mu nepoÅ¡lou, si vyberou na cviÄenÃ­ z volnÃ½ch tÃ©mat, pÅ™Ã­padnÄ› jim bude tÃ©ma pÅ™iÅ™azeno.
</p>
<p>
VÅ¡echny programy vypisujÃ­ ladicÃ­ vÃ½pisy na chybovÃ½ vÃ½stup. Na chybovÃ½ vÃ½stup se takÃ© zobrazujÃ­ vÅ¡echny informace o udÃ¡lostech v bÄ›hu programu (jako je rozpojenÃ­ spojenÃ­, routovacÃ­ informace,
informace o chybÃ¡ch v pÅ™iajatÃ½ch telegramech).
</p>
<p>
VÅ¡echny programy jsou zaloÅ¾enÃ© na standardu POSIX zkompilovatelnÃ½m pro UNIXovÃ½ systÃ©m.
</p>

    <h2 id="u2">1. NavazovanÃ© spojenÃ­</h2>
    <p>Implementujte potvrzovanÃ© spojenÃ­ splÅˆujÃ­cÃ­ nÃ¡sledujÃ­cÃ­ protokolovÃ½ stack. JednÃ¡ se o pÅ™Ã­klad zajiÅ¡tÄ›nÃ© komunikace, kdy klient a server si pravidelnÄ› vymÄ›ÅˆujÃ­ data o svÃ©m stavu.
    Realace se zklÃ¡dÃ¡ z fÃ¡ze navazovÃ¡nÃ­ spojenÃ­, kdy mÅ¯Å¾e dochÃ¡zet i k ovÄ›Å™ovÃ¡nÃ­ identity komunikojÃ­cÃ­ch stran. NavazovÃ¡nÃ­ spojenÃ­ se vÅ¾dy dÄ›je tak, Å¾e klient Å¾Ã¡dÃ¡ o spojenÃ­ a server vyÄkÃ¡vÃ¡ na spojenÃ­ od klienta.
    Pro spojenÃ­ se vyuÅ¾ije soket typu stream.
    </p><table border="1">
<tbody><tr><td>DatovÃ¡ vrstva</td><td>DatovÃ¡ vrstva pouÅ¾ije pro spojenenÃ­ sokety. Po soketech se budou vysÃ­lat pouze znaky '0'-'9' a 'a'-'f' a znak ','. KaÅ¾dÃ½ bajt, kterÃ½ mÃ¡ bÃ½t vyslÃ¡n bude pÅ™eveden do trojice znakÅ¯ reprezentujÃ­cÃ­ch jeho hex
  hodnotu a znak ','. ZaÄÃ¡tek a konec telegramu urÄujÃ­ dva znaky ',' vyslanÃ© bezprostÅ™ednÄ› za sebou.
  <br>
  PÅ™Ã­klad vyslÃ¡nÃ­ telegramu o 6-ti bajtech a hodnotÃ¡ch 0x04, 0x0d, 0x55, 0x32, 0x32, 0x58:  <br>
       <code>,,04,0d,55,32,32,58,,</code></td></tr>
       <tr><td>TransportnÃ­ vrstva</td><td>TransportnÃ­ vrstva pÅ™Ã­dÃ¡ na zaÄÃ¡tek vysÃ­lanÃ©ho telegramu dva bajty: dÃ©lku dat bez hlaviÄky a kontrolnÃ­ souÄet. KontrolnÃ­ souÄet se vypoÄte jako bitovÃ½ XOR vÅ¡ech hodnot zasÃ­lanÃ©ho telegramu. 
       PÅ™i pÅ™Ã­jmu telegramu se tento kontrolnÃ­ souÄet otestuje a relaÄnÃ­ vrstvÄ› se pÅ™edajÃ­ pouze telegramy se sprÃ¡vnÃ½m kontrolnÃ­m souÄtem</td></tr>
       <tr><td>RelaÄnÃ­ vrstva</td><td>RelaÄnÃ­ vrstva navazuje spojenÃ­ a kontroluje vÃ½padek zprÃ¡v. Pro navÃ¡zÃ¡nÃ­ relace spojenÃ­ slouÅ¾Ã­ telegram t0 nÃ¡sledujÃ­cÃ­ho formÃ¡tu:
  <br>
  <strong>t0</strong> : <table class="packet"><tbody><tr><td>0x10</td><td>sekv_a_low</td><td>sekv_a_high</td><td>8 bajtÅ¯ jmÃ©na</td><td>0x11</td></tr></tbody></table>
         <br>
Klient i server si pÅ™i spuÅ¡tÄ›nÃ­ vygenerujÃ­ nÃ¡hodnou hodnotu poÄÃ¡teÄnÃ­ sekvenÄnÃ­ znaÄky. Klient poÅ¡le telegram t0 se svojÃ­ sekvenÄnÃ­ 
       znaÄkou, server odpovÃ­ telegramem t0 se svojÃ­ sekvenÄnÃ­ znaÄkou. Pro dalÅ¡Ã­ komunikaci se pouÅ¾ije sekvenÄnÃ­ znaÄka souÄtu obou tÄ›chto znaÄek. Pro pÅ™enos zprÃ¡v se pouÅ¾ije telegram t1, kterÃ½ mÃ¡
       formÃ¡t:  <br>
		 <strong>t1</strong> : <table class="packet"><tbody><tr><td>0x20</td><td>sekv_a_low</td><td>sekv_a_high</td><td>32 bajtÅ¯ zprÃ¡vy</td><td>0x21</td></tr></tbody></table>
	   <br>
       Po vyslÃ¡nÃ­ telegramu je vÅ¾dy sekvenÄnÃ­ znaÄka inkrementovÃ¡na. PÅ™i pÅ™Ã­jmu chybnÃ© sekvenÄnÃ­ znaÄky, nebo pÅ™i pÅ™Ã­jmu telegramu T0 je relace zruÅ¡ena (to znamenÃ¡, Å¾e je potÅ™eba, aby doÅ¡lo k vÃ½mÄ›nÄ› 2 telegramÅ¯ T0 s novÃ½mi aktuÃ¡lnÃ­mi
       sekvenÄnÃ­mi znaÄkami - socket se neuzavÃ­rÃ¡ ten je souÄÃ¡stÃ­ datovÃ© vrstvy). 
       Klient relaci zruÅ¡Ã­ pokud server neodpovÃ­ do vyslÃ¡nÃ­ nÃ¡sledujÃ­cÃ­ho telegramu. 
  <br>
       PÅ™Ã­klad navÃ¡zÃ¡nÃ­ spojenÃ­:
       <code><table border="1">
		 <tbody><tr><td><b>Klient</b></td><td><b>Server</b></td></tr>
<tr><td>0x10 | 0x88 | 0x55 | K | L | I | E | N | T | 0 | 0 | 0x11 </td><td>0x10 | 0x10 | 0x00 | S | E | R | V | E | R | 5 | 5 | 0x11</td></tr>
<tr><td>0x20 | 0x99 | 0x55 | Z | P | R | A | V | A | 1 | 0x21 </td><td>0x20 | 0x99 | 0x55 | Z | P | R | A | V | A | 3 | 0x21</td></tr>
<tr><td>0x20 | 0x9A | 0x55 | Z | P | R | A | V | A | 2 | 0x21 </td><td>0x20 | 0x9A | 0x55 | Z | P | R | A | V | A | 3 | 0x21</td></tr>
<tr><td>0x20 | 0x9B | 0x55 | Z | P | R | A | V | A | 2 | 0x21 </td><td>0x20 | 0x9B | 0x55 | Z | P | R | A | V | A | 3 | 0x21</td></tr>
</tbody></table> 
       </code>
       </td></tr>
		 <tr><td>AplikaÄnÃ­ vrstva</td><td>UÅ¾ivatel posÃ­lÃ¡ a pÅ™Ã­jÃ­mÃ¡ telegramy o maximÃ¡lnÃ­ dÃ©lce 32 bajtÅ¯. Klient zasÃ­lÃ¡ telegramy v intervalu 1 sekunda, server odpovÃ­dÃ¡ pouze na pÅ™ijatÃ½ telegram.<br>
       Server mÅ¯Å¾e odpovÄ›dÄ›t pouze mÃ¡-li k dispozici vstupnÃ­ data. Pokud uÅ¾ivatel data nezadal, nemÃ¡ server oprÃ¡vnÄ›nÃ­ k navÃ¡zÃ¡nÃ­ spojenÃ­.</td></tr>
</tbody></table>
    <p></p>
<p>
Klient Äte data ze standardnÃ­ho vstupu oddÄ›lenÃ¡ znakem <em>novÃ½_Å™Ã¡dek</em> (EOL = 0x0A) a zadanÃ¡ data vysÃ­lÃ¡ pravidelnÄ› kaÅ¾dou vteÅ™inu (za pÅ™edpokladu Å¾e neÄekÃ¡ na vstup).
Server Äte data stejnÃ½m zpÅ¯sobem a data posÃ­lÃ¡ jako odpovÄ›Ä na telegram od klienta. Je zÅ™ejmÃ©, Å¾e server ÄekÃ¡ na 2 typy udÃ¡lostÃ­ (standartnÃ­ vstup a socket), proto vyÅ¾aduje implementaci s minimÃ¡lnÄ› dvÄ›mi vlÃ¡kny (nebo pouÅ¾itÃ­ funkce <em>select</em>).
<br><br>
Klient i server musÃ­ bÃ½t odolnÃ­ na chybu ve spojenÃ­, tady musÃ­ se sprÃ¡vnÄ› zachovat pÅ™i chybÄ› kontrolnÃ­ho souÄtu, pÅ™i chybÄ› datovÃ© vrstvy a pÅ™i chybÄ› relaÄnÃ­ vrstvy. Telegram s chybou je zahozen. V tomto pÅ™Ã­padÄ› se nejednÃ¡ o potvrzovanÃ© spojenÃ­, takÅ¾e zahozenÃ¡ data se jiÅ¾ opakovanÄ› nevysÃ­lajÃ­.
<br><br>
  Klient se spouÅ¡tÃ­ s 3 parametry: IP_serveru, port_serveru, jmeno. 
  <br>
  Server se spouÅ¡tÃ­ s 2 parametry: port_serveru, jmeno. 
</p>

    <h2 id="u2">2. PotvrzovanÃ© spojenÃ­</h2>
    <p>Implementujte potvrzovanÃ© spojenÃ­ vyuÅ¾Ã­vajÃ­cÃ­ nÃ¡sledujÃ­cÃ­ algoritmus:
    </p><table>
<tbody><tr><td>a) <a href="http://en.wikipedia.org/wiki/Go-Back-N_ARQ">Go Back N ARQ</a></td><td>Implementujte algoritmus Go back N pro N=8. </td></tr>
       <tr><td>b) <a href="http://en.wikipedia.org/wiki/Selective_Repeat_ARQ">Selective Repeat ARQ</a></td><td>Implementujte algoritmus selective repeat pro N=8. </td></tr>
</tbody></table>
    <p></p>
<p>
Program klient na zaÄÃ¡tku otevÅ™e soketovÃ© pÅ™ipojenÃ­ podle zadanÃ½ch argumentÅ¯ (IP a ÄÃ­slo portu) a dÃ¡le vysÃ­lÃ¡ zprÃ¡vy, kterÃ© si pÅ™eÄte ze standardnÃ­ho vstupu (zprÃ¡vy jsou oddÄ›leny znakem <em>NovÃ¡_Å™Ã¡dka</em> (EOL = 0x10) a jsou oÅ™ezÃ¡ny, nebo doplnÄ›ny na pevnou dÃ©lku). 
PÅ™i EOF ukonÄÃ­ soketovÃ© spojenÃ­.<br>
Klient pÅ™ed kaÅ¾dou zprÃ¡vu pÅ™idÃ¡ hlaviÄku, kterÃ¡ bude obsahovat dva bajty sekvenÄnÃ­ho ÄÃ­sla. Pro posÃ­lÃ¡nÃ­ zprÃ¡v vyuÅ¾ijte soketu typu Datagram (UDP). VÅ¡echny posÃ­lanÃ© zprÃ¡vy budou mÃ­t pevnou dÃ©lku.
Program klient podle generÃ¡toru nÃ¡hodnÃ½ch ÄÃ­sel buÄ zprÃ¡vu s pravdÄ›podobnostÃ­ 0.9 odeÅ¡le, nebo bude s pravdÄ›podobnostÃ­ 0.1 simulovat vÃ½padek telegramu (tedy neodeÅ¡le Å¾Ã¡dnÃ½ bajt zprÃ¡vy).
<br>
Program server pÅ™ijÃ­mÃ¡ telegramy a vysÃ­lÃ¡ potvrzenÃ­ o jejich pÅ™ijetÃ­. Server takÃ© podle generÃ¡toru nÃ¡hodnÃ½ch ÄÃ­sel s pravdÄ›podobnostÃ­ 0.9 zaÅ¡le potvrzenÃ­ a s pravdÄ›podobnostÃ­ 0.1 potvrzenÃ­ zahodÃ­.
Server na standardnÃ­ vÃ½stup zobrazuje pÅ™ijatÃ© zprÃ¡vy.
<br><br>
  Klient se spouÅ¡tÃ­ s 2 parametry: IP_serveru, port_serveru. 
  <br>
  Server se spouÅ¡tÃ­ s 1 parametrem: port_serveru. 
</p>
    

 <h2 id="u2">3. Klient - server</h2>
    <p>V tÃ©to Ãºloze mÃ¡te za Ãºkol naprogramovat dva samostatnÃ© programy klient a server.
PÅ™i startu se klient podle zadanÃ½ch ÃºdajÅ¯ pÅ™ihlÃ¡sÃ­ na server. <br>
Jako prvnÃ­ zaÅ¡le Å™etÄ›zec zakonÄenÃ½ 0 o maximÃ¡lnÃ­ dÃ©lce 16 znakÅ¯. Tento Å™etÄ›zec pÅ™edstavuje jmÃ©no pod kterÃ½m se klient pÅ™ihlaÅ¡uje k serveru.
NÃ¡slednÄ› klient zasÃ­lÃ¡ maximÃ¡lnÄ› 256 znakovÃ© zprÃ¡vy jinÃ½m klientÅ¯m podle jmÃ©na.
ZprÃ¡vy jsou Äteny ze standardnÃ­ho vstupu ve tvaru <code>jmeno:zprÃ¡va</code> (ukonÄenÃ© znakem <em>NovÃ¡_Å™Ã¡dka</em>).
NaÄtenÃ© zprÃ¡vy jsou ihned odesÃ­lÃ¡ny na server.
<br>
Server zprÃ¡vy pÅ™eposÃ­lÃ¡ pÅ™ihlÃ¡Å¡enÃ½m klientÅ¯m.
Pokud je zprÃ¡va urÄena pro klienta, kterÃ½ jeÅ¡tÄ› nikdy nebyl pÅ™ihlÃ¡Å¡en, nebo kterÃ½ nenÃ­ dostupnÃ½, server zprÃ¡vu uloÅ¾Ã­. 
Server si pro kaÅ¾dÃ©ho klienta pamatuje maximÃ¡lnÄ› 16 poslednÃ­ch zprÃ¡v.
MaximÃ¡lnÃ­ poÄet rÅ¯znÃ½ch klientÅ¯, kteÅ™Ã­ se mohou pÅ™ihlÃ¡sit je 256.
Server musÃ­ umoÅ¾nit souÄasnÃ© pÅ™ihlÃ¡Å¡enÃ­ aÅ¾ 32 klientÅ¯.
<br>
Pokud se Klient pÅ™ihlÃ¡sÃ­, jsou mu automaticky zaslÃ¡ny vÅ¡echny uloÅ¾enÃ© zprÃ¡vy.
PÅ™i ukonÄenÃ­ klienta je nutnÃ© poslat serveru zprÃ¡vu oznamujÃ­cÃ­ odpojenÃ­ klienta.
<br>
Pro komunikaci pouÅ¾ijte soket typu Datagram (UDP).
Strukturu komunikaÄnÃ­ch datagramÅ¯ si navrhnÄ›te sami.
</p>
<p>
Klient se spouÅ¡tÃ­ s 3 parametry: IP_serveru, port_serveru, jmeno. 
<br>
Server se spouÅ¡tÃ­ s 1 parametrem: port_serveru. 
</p>

<h2 id="u2">4. DynamickÃ© smÄ›rovÃ¡nÃ­</h2>
    <p>V tÃ©to Ãºloze mÃ¡te za Ãºkol naprogramovat jeden program, kterÃ½ se chovÃ¡ jako klient i server souÄasnÄ›. Program si pÅ™i spuÅ¡tÄ›nÃ­ pÅ™eÄte svÅ¯j konfiguraÄnÃ­ soubor kterÃ½ mÃ¡ nÃ¡sledujÃ­cÃ­ strukturu:
       </p><table border="1">
<tbody><tr><td>1. Å™Ã¡dka</td><td>obsahuje ID programu, kterÃ½m se bude hlÃ¡sit v sÃ­ti</td></tr>
<tr><td>2. Å™Ã¡dka</td><td>obsahuje ÄÃ­slo protu, kde bude oÄekÃ¡vat pÅ™ipojenÃ­ klientÅ¯</td></tr>
<tr><td>3. Å™Ã¡dka</td><td>obsahuje poÄet spojenÃ­, kterÃ© program navÃ¡Å¾e jako klient (toto ÄÃ­slo je nejvÃ½Å¡e 4)</td></tr>
<tr><td>4.-N. Å™Ã¡dka</td><td>obsahuje IP adresu a port pro navÃ¡zÃ¡nÃ­ spojenÃ­ k serveru</td></tr>
</tbody></table>
    <br>
    KaÅ¾dÃ½ program umoÅ¾nÃ­ maximÃ¡lnÄ› 4 pÅ™ipojenÃ­ jako server a 4 pÅ™ipojenÃ­ jako klient. VÅ¡echna navÃ¡zanÃ¡ spojenÃ­ jsou obousmÄ›rnÃ¡ a tvÃ¡Å™Ã­ se jako propojenÃ­ EthernetovÃ½m spojenÃ­m.
Program vyuÅ¾Ã­vÃ¡ nÄ›kterÃ½ ze znÃ¡mÃ½ch algoritmÅ¯ <a href="http://en.wikipedia.org/wiki/Routing">smÄ›rovÃ¡nÃ­</a>, nebo VÃ¡Å¡ vlastnÃ­ pÅ™Ã­stup. Program Äte ze standardnÃ­ho vstupu zprÃ¡vy ve formÃ¡tu 
<code>ID_AdresÃ¡ta:zprÃ¡va</code>, kde zprÃ¡va obsahuje maximÃ¡lnÄ› 128 bajtÅ¯, delÅ¡Ã­ zprÃ¡va je oÅ™Ã­znuta.
V komunikaci mezi programy mÅ¯Å¾ete pouÅ¾Ã­t telegramy delÅ¡Ã­ch dÃ©lek (bude tÅ™eba si k telegramu pÅ™idÃ¡vat informace o cestÄ› telegramu).
Pro komunikaci pouÅ¾ijte soket typu Datagram (UDP).
<br>
VÅ¡echny ID v systÃ©mu jsou jednobajtovÃ¡ ÄÃ­sla v rozsahu 1..255. ÄŒÃ­slo 0 je rezervovÃ¡no pro testovÃ¡nÃ­ spojenÃ­ a vÃ½mÄ›nu smÄ›rovacÃ­ch informacÃ­.
<br>
SystÃ©m by mÄ›l doruÄit zprÃ¡vu alespoÅˆ jednou (rozhodnÄ› nikdy ne dvakrÃ¡t, i kdyÅ¾ zprÃ¡vu mÅ¯Å¾e rozdvojit a poslat vÃ­ce cestami).
ZprÃ¡vy kterÃ© nelze doruÄit se zahodÃ­.
RovnÄ›Å¾ je povoleno zahodit zprÃ¡vy, kterÃ© se nevejdou do buferu programu (pokud bude v systÃ©mu jen jedna zprÃ¡va a bude existovat cesta, pak ji musÃ­ doruÄit).
<br>
Pokud bude VÃ¡Å¡ systÃ©m schopen oznÃ¡mit nedoruÄitelnost zprÃ¡vy, pak jsou to kladnÃ© body, kterÃ© mohou vyvÃ¡Å¾it Äitelnost programu. RozhodnÄ› musÃ­te bÃ½t schopni vysvÄ›tlit pÅ™i pÅ™edÃ¡vÃ¡nÃ­ mechanismus, kterÃ½ detekuje nedoruÄitelnost.
<p></p>

 
</body></html>Ytext/htmlUUTF-8T_new_?http://labe.felk.cvut.cz/~stepan/33OSS/semestralky-network.html    ( : P n … ”3À3Ê3Ğ3Õ                           4